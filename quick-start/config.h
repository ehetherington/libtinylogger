/* config.h.  SUBSTITUTE for Generated from config.h.in by configure.  */

/*
 * Normally config.h is generated by running configure.sh 
 * These are the relevant compile time parameters needed to build the library
 * in the quick-start directory without use of autotools.
 */

/*
 * There are potentially two copies of this file.
 * The original is in the quick-start directory. If you create the tree in
 * another directory, it will be copied there by setup.sh.
 *
 * Make sure you modify the right one.
 *
 * Of course, you can change the quick-start/config.h file and run setup.sh
 * again.
 */

/*
 * This is a cheat in case you don't have the real <systemd/sd-daemon.h>
 * installed.
 * If you have <systemd/sd-daemon.h> installed on your system, you must change
 * in order for it to be used.
 */
/* Define to 1 if you have the <systemd/sd-daemon.h> header file. */
#define HAVE_SYSTEMD_SD_DAEMON_H 0

/*
 * The log messages are limited to a maximum of 8k characters by default.
 * This only applies to the user message part, not the timestamp, log level,
 * etc.
 *
 * They are constructed on the stack (by default), and that is the size of the
 * buffer allocated on the stack. The size of that buffer may be adjusted by
 * setting MAX_MSG_SIZE. If you are worried about stack size, it may be reduced
 * to something like 256, for instance.
 * 
 * If you are using log_memory() and want to log large chunks of memory,
 * the 8k limit may be a problem. The hex dump format uses 2 hex chars + a
 * space + ascii equivalent per byte, plus some other overhead, So you end up
 * being able to log less than 2k of memory.
 *
 * If MAX_MSG_SIZE is set to 0, the messages are constructed with vasprintf().
 * The user messages are then constructed in heap, and there is no limit. This
 * costs about 10 - 20% execution time penalty for basic and systemd formats.
 * The penalty percentage decreases for more complicated message formats.
 * (For ALL messages, not just memory dumps).
 */
//#define MAX_MSG_SIZE 0

/*
 * JSON output specific.
 * JSON log files may have a small header before the list of records.
 *
 * The header field name is "logHeader", and has three fields:
 * 1) startDate - a timestamp for when the log channel was configured. If
 *    ENABLE_TIMEZONE is set, the Olson timezone will be appended as in all
 *    other timestamps.
 * 2) hostname - read from /proc/sys/kernel/hostname
 * 3) comment - currently no api is available to supply a comment. It will be
 *    empty.
 */
/* Define to 1 to enable header in JSON logs */
#define ENABLE_JSON_HEADER 1


/*
 * JSON output specific.
 * Locating the timezone on different Linux distros varies. This software has
 * been tested on RHEL8 and Raspbian/buster (Debian based). A program in the
 * demo (example) directory called check-timezone will display the timezone
 * found. If it finds a timezone and it is correct, use of timezones in the
 * JSON output format may be enabled.
 */
/* Define to 1 to enable timezone in JSON timestamps */
#define ENABLE_TIMEZONE 1


/*
 * JSON output specific.
 * If ENABLE_TIMEZONE has been set, getting the timezone verifies it against
 * the Olson timezone database. If yours is not in /usr/share/zoneinfo, that
 * must be set with the following:
 */
/* For example:
 * #define ZONEINFO_DIR "/my/olson/database"
 */
//#define ZONEINFO_DIR "/usr/share/zoneinfo"

/*
 * TIMEZONE_TEST must be defined for examples/json-timezones.c to work
 * TIMEZONE_TEST must NOT be defined for normal usage
 * TIMEZONE_TEST is used in json-formatter.c, and may be defined directly there
 */
//#define TIMEZONE_TEST

